[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18379836&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is an aspect of technology, that allows one to bring solutions to complex problems through research, analytics and innovation. It is a field, that allows users to conveniently have access to apps or websites that makes life easier. 
It is very important in the technology industry because, through codes, one is able to bring their innovative thoughts and ideas to life which aims at solving a problem. Assuming I want to build a house, but do not know where to start from, I have an idea of how I want the building to look like, software engineering gives us the opportunity to not only write blocks of code but also, bring out meaningful solutions that address real world problems. These solutions are reliable, efficient, accessible and flexible. An app aimed at tracking medical health status, allows the patient to monitor their health status from the comfort of their homes even at odd times, reducing workload on the part of the doctor. A blog that is focused on farming, allows other farmers have insights on ways to increase crop yield, reduce mortality rate in both animal and plant yield, while promoting sustainable innovative ways in farming. Software engineering does not only focus on a specific sector but cuts across all sectors to make life convenient.


Identify and describe at least three key milestones in the evolution of software engineering.
1. Development:
   Development has evolved from manual, low-level coding to AI-assisted, high-level programming. Early programmers used punch cards and assembly language, while modern developers leverage frameworks, libraries, and AI tools like GitHub Copilot. Today, development focuses on scalability, maintainability, and collaboration, with open-source communities driving innovation.

2. Methodolofy/ Process:
   Methodology/Process shifted from rigid, linear models to flexible, iterative, and automated workflows. The waterfall model gave way to Agile, Scrum, and DevOps, emphasizing collaboration, adaptability, and continuous improvement. Automation tools (e.g., CI/CD pipelines) now enable rapid testing, deployment, and monitoring, reducing human error and speeding up delivery.

3. Machine:
   Machine (Computers) transformed from room-sized mainframes to portable, cloud-based, and quantum systems. Early computers were limited to scientific and military use, while personal computers and smartphones brought computing to the masses. Cloud computing and edge computing now provide on-demand resources, while quantum computing promises to solve previously intractable problems.
   
List and briefly explain the phases of the Software Development Life Cycle.
1. Requirement analysis: Identify the software needs by defining and documenting the requirements and scope needed.
2. Planning: Create a roadmap for the project. 
3. Design: Create a design for the entire project flow.
4. Coding: Implement the design by writing blocks of code.
5. Testing: Test the software for bugs, errors and issues that might impact its efficiency.
6. Deployment: Make the software or project available to users.
7.  Maintainability: Ensure the software still serves the purpose it is supposed to by maintaining and improving upon the software.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall is a linear, sequential approach where all requirements are defined upfront, making it ideal for stable, predictable projects like payroll systems. In contrast, Agile is iterative and flexible, adapting to changing needs and involving customers continuously throughout the process. Waterfall relies on extensive documentation and delivers the final product only at the end, while Agile uses lightweight documentation and releases updates in small, frequent increments. Agile is best suited for dynamic projects like mobile apps or startups, where quick feedback and adaptability are crucial. Waterfall works well when requirements are clear and unlikely to change, while Agile thrives in environments where collaboration and evolution are key. Choose Waterfall for rigidity and predictability, and Agile for flexibility and customer-centric development.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Software Developer
Role: The builder who writes the code to create the software.

Responsibilities:

Write and test code to build features and fix bugs.

Work with designers to turn ideas into functional software.

Collaborate with QA engineers to ensure the code works as expected.


2. Quality Assurance (QA) Engineer
Role: The tester who ensures the software works correctly and is free of bugs.

Responsibilities:

Test the software to find and report bugs or issues.

Work with developers to fix problems before the software is released.

Ensure the software meets quality standards and user expectations.
Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.


3. Project Manager
Role: The organizer who keeps the team on track and ensures the project is completed on time and within budget.

Responsibilities:

Plan the project timeline, assign tasks, and manage resources.

Communicate with stakeholders (e.g., clients or executives) to align on goals.

Solve problems and keep the team focused on deadlines.



What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
 Scalability Issues
Challenge: Designing systems that can handle growth in users or data.

Strategies:

Modular Design: Build systems with modular components that can scale independently.

Cloud Solutions: Use cloud services like AWS, Azure, or Google Cloud for scalable infrastructure.

Load Testing: Perform load testing to identify bottlenecks and optimize performance.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing: This involves testing individual components or units of a software application in isolation to verify that each part functions correctly on its own.

Integration Testing: After unit testing, integration testing examines the interactions between combined units to identify interface defects and ensure that integrated components work together as intended.

System Testing: This level of testing evaluates the complete and integrated software system to verify that it meets the specified requirements.

Acceptance Testing: Conducted to determine whether the software meets the business requirements and is ready for deployment, acceptance testing ensures the system satisfies the criteria set by the end-users or clients.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the act of sending a interacting with an AI model to generate a response to that very prompt that has been sent. Knowing how to interact with AI models, allows us have accurate or almost accurate answers or solutions to our problems or answers to one's questions.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Assuming I am a grade 4 student who would like to understand and know what a Noun is.
Vague prompt: What is a noun?

Improved prompt: What is a noun, explain what it means with examples and break it down to the understanding of a grade 4 student.
The improved prompt is more effective because, it highlights and alerts the model of the level of understanding of the user, without specifying the grade of the student and asking for a breakdown and examples, it would be quite difficult for the student to understand as the model will just give a definition without the need to explain or nreak anything down.
